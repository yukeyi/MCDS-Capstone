import numpy as np
import SimpleITK as sitk
import random

'''
This function generate points from fixedImage with given ranges.

hd must be either 'index' or 'point'
'''


def generate_points(x_range=[], y_range=[], z_range=[], filename='test.pts', hd='index'):
    assert (hd == 'index' or hd == 'point')
    res = np.zeros((len(x_range) * len(y_range) * len(z_range), 3))
    fr = open(filename, 'w')
    fr.write(hd + '\n' + str(len(x_range) * len(y_range) * len(z_range)))
    num_row = 0
    for i in range(len(x_range)):
        for j in range(len(y_range)):
            for k in range(len(z_range)):
                x = np.array([x_range[i], y_range[j], z_range[k]]).astype('float')
                s = np.array2string(x, formatter={'float_kind': lambda x: "%.1f" % x}).lstrip('[').rstrip(']')
                fr.write('\n' + s)
                res[num_row] = x
                num_row += 1
    fr.close()
    return res.astype('int')


'''
The function reads from output file generated by transformation and get the output coordinates
'''


def get_output_points(filename='outputpoints.txt'):
    fr = open(filename, 'r')

    res = None
    for line in fr.readlines():
        line = line[line.index('OutputIndexFixed = ') + len('OutputIndexFixed = '):]
        line = line[:line.index('\t')].lstrip('[').rstrip(']')
        array = np.fromstring(line, dtype=int, sep=' ')
        if res is None:
            res = array.reshape(1, 3)
        else:
            res = np.concatenate((res, array.reshape(1, 3)), 0)

    return res


'''
This function creates index of imageArray from coordinates
'''


def create_index(points, patch_size):
    i = points[:, 0].reshape(patch_size[0], patch_size[1], patch_size[2])
    j = points[:, 1].reshape(patch_size[0], patch_size[1], patch_size[2])
    k = points[:, 2].reshape(patch_size[0], patch_size[1], patch_size[2])
    return i, j, k


'''
This function creates masks given indices. The mask is the same size as image
'''


def create_mask(shape, i, j, k):
    mask = np.zeros(shape)
    mask[i, j, k] = 1
    return mask


'''
Return two lists of corresponding patches. 
'''


def generate_patches(fixedImage, movingImage, transformParameterMap, filename='test.pts', patch_size=[16, 40, 40],
                     padding=20):
    elastixImageFilter = sitk.ElastixImageFilter()
    elastixImageFilter.SetFixedImage(fixedImage)
    elastixImageFilter.SetMovingImage(movingImage)
    # elastixImageFilter.SetParameterMap(parameterMap)

    """ use non-linear parameter map """
    parameterMapVector = sitk.VectorOfParameterMap()
    parameterMapVector.append(sitk.GetDefaultParameterMap("affine"))
    parameterMapVector.append(sitk.GetDefaultParameterMap("bspline"))
    elastixImageFilter.SetParameterMap(parameterMapVector)
    elastixImageFilter.Execute()

    transformParameterMap = elastixImageFilter.GetTransformParameterMap()

    movingImageArray = sitk.GetArrayFromImage(movingImage)
    fixedImageArray = sitk.GetArrayFromImage(fixedImage)

    assert(fixedImageArray.shape[1] > 40+patch_size[1] and fixedImageArray.shape[2] > 40+patch_size[2] and
           fixedImageArray.shape[0] >= 4+patch_size[0])

    time = 1
    while(True):
        middle_x = random.randint(2+patch_size[0]//2, fixedImageArray.shape[0]-2-patch_size[0]//2)
        middle_y = random.randint(20+patch_size[1]//2, fixedImageArray.shape[1]-20-patch_size[1]//2)
        middle_z = random.randint(20+patch_size[2]//2, fixedImageArray.shape[2]-20-patch_size[2]//2)

        x_range = np.array(range(middle_x-patch_size[0]//2, middle_x+patch_size[0]//2))
        y_range = np.array(range(middle_y-patch_size[1]//2, middle_y+patch_size[1]//2))
        z_range = np.array(range(middle_z-patch_size[2]//2, middle_z+patch_size[2]//2))

        original_points = generate_points(x_range, y_range, z_range)

        transformixImageFilter = sitk.TransformixImageFilter()
        transformixImageFilter.SetTransformParameterMap(transformParameterMap)
        transformixImageFilter.SetFixedPointSetFileName(filename)
        transformixImageFilter.SetMovingImage(movingImage)
        transformixImageFilter.Execute()

        transformed_points = get_output_points()
        if indexIsValid(transformed_points) == False:
            time += 1
            continue

        i, j, k = create_index(original_points, patch_size)
        original_patch = fixedImageArray * create_mask(fixedImageArray.shape, i, j, k)
        i, j, k = create_index(transformed_points, patch_size)
        transformed_patch = movingImageArray * create_mask(movingImageArray.shape, i, j, k)

        print("Done " + str(time) + " times registration")
        #print(original_patch.shape)
        #print(transformed_patch.shape)

        return original_patch, transformed_patch



def indexIsValid(points):
    return (points.flatten() < 0).sum() == 0

#generate_patches(fixedImage, movingImage, elastixImageFilter.GetTransformParameterMap())